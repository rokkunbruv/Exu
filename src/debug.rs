use crate::cli::DebugArgs;
use crate::compiler::Executable;
use crate::instruction::Instr;
use crate::program::Program;
use crate::token::Token;
use crate::vm::RegisterType;
use crate::Spanned;
use chumsky::prelude::Rich;
use std::error::Error;

#[derive(Clone)]
pub struct DebugConfig {
    pub debug_flags: DebugArgs,
}

impl DebugConfig {
    pub fn new(debug_flags: DebugArgs) -> Self {
        Self { debug_flags }
    }

    /// Displays the generated tokens as well as any lexing errors during the lexing stage
    pub fn log_lexer_result(
        &self,
        tokens: &Option<Vec<Spanned<Token>>>,
        lexer_errors: &Vec<Rich<'_, char>>,
    ) {
        if !self.debug_flags.debug_config {
            return;
        }

        println!(
            "=====TOKENS=====\n{:?}\n=====ERRORS=====\n{:?}\n",
            tokens, lexer_errors
        );
    }

    /// Displays the generated AST as well as any parsing errors during the parsing stage
    pub fn log_parser_result(
        &self,
        program: &Option<Spanned<Program>>,
        parse_errors: &Vec<Rich<'_, Token>>,
    ) {
        if !self.debug_flags.debug_config {
            return;
        }

        println!(
            "=====AST TREE=====\n{:?}\n=====ERRORS=====\n{:?}\n",
            program, parse_errors
        );
    }

    /// Displays the typechecker result
    pub fn log_typechecker_result(&self, typecheck_result: &Result<(), Box<dyn Error>>) {
        if !self.debug_flags.debug_config {
            return;
        }

        match typecheck_result {
            Ok(_) => println!("=====TYPE CHECK STATUS=====\nSUCCESS\n"),
            Err(typecheck_error) => {
                println!("=====TYPE CHECK STATUS=====\nERROR:{:?}\n", typecheck_error);
            }
        }
    }

    /// Displays the generated bytecode instructions as well as any compile errors during the compiling stage
    pub fn log_compiler_result(&self, compile_result: &Result<Executable, Box<dyn Error>>) {
        if !self.debug_flags.debug_config {
            return;
        }

        match compile_result {
            Ok(program) => {
                println!(
                    "=====BYTECODE=====\n{:?}\n=====LABELS=====\n{:?}\n",
                    &program.instructions, &program.labels
                );
            }
            Err(compile_error) => {
                println!("=====COMPILATION ERROR=====\n{:?}\n", compile_error);
            }
        }
    }

    /// Displays the instruction to be executed
    pub fn log_instr(&self, instruction: &Instr, instruction_count: u32) {
        if !self.debug_flags.debug_config {
            return;
        }

        println!("PC={:?} {:?}", instruction_count, instruction);
    }

    /// Displays the register and heap values of the VM
    pub fn log_vm_state(&self, registers: &RegisterType) {
        if !self.debug_flags.show_vm_states {
            return;
        }

        for reg in registers.iter() {
            print!("{:?} ", reg);
        }
        println!("\n");
    }
}
