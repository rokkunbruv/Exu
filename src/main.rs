mod ast;
mod cli;
mod compiler;
mod debug;
mod error;
mod instruction;
mod lexer;
mod parser;
mod program;
mod token;
mod type_checker;
mod types;
mod value;
mod vm;

use chumsky::{prelude::*, Parser};
use clap::Parser as CliParser;
use cli::{Cli, Commands};
use compiler::Compiler;
use debug::DebugConfig;
use error::report_syntax_errors;
use lexer::lexer;
use parser::parser;
use program::Program;
use std::{
    fs::File,
    io::{self, Read, Write},
};
use type_checker::TypeChecker;
use vm::VM;

pub type Span = SimpleSpan;
pub type Spanned<T> = (T, Span);

fn main() {
    let cli = Cli::parse();
    let path;

    if let Some(Commands::Debug(ref args)) = cli.command {
        path = args.path.clone();
    } else {
        path = cli.path.clone();
    }

    match path {
        Some(p) => run_file(&cli, &p),
        None => run_repl(&cli),
    };
}

/// Executes the provided source string
fn run(cli: &Cli, source: String) {
    let debug_config;

    match &cli.command {
        Some(Commands::Debug(dbg_args)) => debug_config = Some(DebugConfig::new(dbg_args.clone())),
        None => debug_config = None,
    }

    // Lexer: Convert source string to tokens
    let (tokens, lexer_errs) = lexer().parse(&source).into_output_errors();

    // Log lexer result
    if let Some(dbg_cfg) = &debug_config {
        dbg_cfg.log_lexer_result(&tokens, &lexer_errs);
    }

    // This should not panic since any lexical errors are already being handled
    let tokens = tokens.unwrap();

    // Parser: Convert tokens to AST
    let (program, parse_errs) = parser()
        .map_with(|prog, e| (prog, e.span()))
        .parse(
            tokens
                .as_slice()
                .map((source.len()..source.len()).into(), |(t, s)| (t, s)),
        )
        .into_output_errors();

    // Log parser result
    if let Some(dbg_cfg) = &debug_config {
        dbg_cfg.log_parser_result(&program, &parse_errs);
    }

    if let None = program {
        report_syntax_errors(lexer_errs, source.as_str());
        report_syntax_errors(parse_errs, source.as_str());
        return;
    }

    let program = program.unwrap();

    if let Some(dbg_cfg) = &debug_config {
        if dbg_cfg.debug_flags.halt_at_parse {
            return;
        }
    }

    // Typechecker: Checks if the type system is consistent in the AST
    let mut type_checker = TypeChecker::new();
    let typecheck_result = type_checker.check_type(&program.0);

    if let Some(dbg_cfg) = &debug_config {
        dbg_cfg.log_typechecker_result(&typecheck_result);

        if dbg_cfg.debug_flags.halt_at_typecheck {
            return;
        }
    }

    if let Err(typecheck_error) = typecheck_result {
        println!("{:?}", typecheck_error);
        return;
    }

    // Compiler: Translates AST to bytecode
    let mut compiler = Compiler::new();
    let compile_result = compiler.compile(&program.0);
    let program;

    if let Some(dbg_cfg) = &debug_config {
        dbg_cfg.log_compiler_result(&compile_result);

        if dbg_cfg.debug_flags.halt_at_compile {
            return;
        }
    }

    match compile_result {
        Ok(prog) => {
            program = prog;
        }
        Err(compile_error) => {
            println!("{:?}", compile_error);
            return;
        }
    }

    // VM: Executes the generated bytecode
    let mut vm = VM::new();
    vm.run(debug_config, program);
}

/// Run the REPL
fn run_repl(cli: &Cli) {
    println!("Running Exu REPL...");

    println!("Exu REPL Version 0.1.0");

    loop {
        let mut source: String = String::new();

        print!(">> ");
        io::stdout()
            .flush()
            .expect("An unexpected error occurred: Failed to flush stdout.");

        io::stdin()
            .read_line(&mut source)
            .expect("Unable to read from input.");

        run(&cli, source.trim().to_string());
    }
}

/// Run a source file given its path
fn run_file(cli: &Cli, path: &str) {
    let mut file: File = File::open(path).expect("Unable to open source file.");

    let mut source: String = String::new();
    file.read_to_string(&mut source)
        .expect("Unable to read source file.");

    run(&cli, source);
}
