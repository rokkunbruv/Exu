mod ast;
mod compiler;
mod instruction;
mod lexer;
mod parser;
mod program;
mod token;
mod type_checker;
mod types;
mod value;
mod vm;

use chumsky::{prelude::*, Parser};
use compiler::Compiler;
use lexer::lexer;
use parser::parser;
use program::Program;
use std::{
    env,
    fs::File,
    io::{self, Read, Write},
};
use type_checker::TypeChecker;
use vm::VM;

pub type Span = SimpleSpan;
pub type Spanned<T> = (T, Span);

fn main() {
    match env::args().nth(1) {
        Some(p) => run_file(&p),
        None => run_repl(), // TODO
    };
}

/// Executes the provided source string
fn run(source: String) {
    // Lexer: Convert source string to tokens
    let (tokens, lex_errs) = lexer().parse(&source).into_output_errors();
    println!(
        "=====TOKENS=====\n{:?}\n=====ERRORS=====\n{:?}\n",
        tokens, lex_errs
    );

    let tokens = tokens.unwrap();

    // Parser: Convert tokens to AST
    let (program, parse_errs) = parser()
        .map_with(|prog, e| (prog, e.span()))
        .parse(
            tokens
                .as_slice()
                .map((source.len()..source.len()).into(), |(t, s)| (t, s)),
        )
        .into_output_errors();

    println!(
        "=====AST TREE=====\n{:?}\n=====ERRORS=====\n{:?}\n",
        program, parse_errs
    );

    let program = program.unwrap();

    // Typechecker: Checks if the type system is consistent in the AST
    let mut type_checker = TypeChecker::new();
    let type_check_result = type_checker.check_type(&program.0);

    match type_check_result {
        Ok(_) => println!("=====TYPE CHECK STATUS=====\nSUCCESS\n"),
        Err(e) => {
            println!("=====TYPE CHECK STATUS=====\nERROR:{:?}\n", e);
            return;
        }
    }

    // Compiler: Translates AST to bytecode
    let mut compiler = Compiler::new();
    let compile_result = compiler.compile(&program.0);
    let program;

    match compile_result {
        Ok(prog) => {
            program = prog;
            println!(
                "=====BYTECODE=====\n{:?}\n=====LABELS=====\n{:?}\n",
                &program.instructions, &program.labels
            );
        }
        Err(e) => {
            println!("=====COMPILATION ERROR=====\n{:?}\n", e);
            return;
        }
    }

    // VM: Executes the generated bytecode
    let mut vm = VM::new();
    vm.run(program);
}

/// Run the REPL
fn run_repl() {
    println!("Running Exu REPL...");

    println!("Exu REPL Version 0.1.0");

    loop {
        let mut source: String = String::new();

        print!(">> ");
        io::stdout()
            .flush()
            .expect("An unexpected error occurred: Failed to flush stdout.");

        io::stdin()
            .read_line(&mut source)
            .expect("Unable to read from input.");

        run(source.trim().to_string());
    }
}

/// Run a source file given its path
fn run_file(path: &str) {
    if !path.ends_with(".exu") {
        panic!("Invalid source file extension. Exu only runs source files ending in \".exu\".");
    }

    let mut file: File = File::open(path).expect("Unable to open source file.");

    let mut source: String = String::new();
    file.read_to_string(&mut source)
        .expect("Unable to read source file.");

    run(source);
}
