mod ast;
mod cli;
mod compiler;
mod instruction;
mod lexer;
mod parser;
mod program;
mod token;
mod type_checker;
mod types;
mod value;
mod vm;

use chumsky::{prelude::*, Parser};
use clap::Parser as CliParser;
use cli::Cli;
use compiler::Compiler;
use lexer::lexer;
use parser::parser;
use program::Program;
use std::{
    env,
    fs::File,
    io::{self, Read, Write},
};
use type_checker::TypeChecker;
use vm::VM;

use crate::cli::Commands;

pub type Span = SimpleSpan;
pub type Spanned<T> = (T, Span);

fn main() {
    let cli = Cli::parse();
    let path;

    if let Some(Commands::Debug(ref args)) = cli.command {
        path = args.path.clone();
    } else {
        path = cli.path.clone();
    }

    match path {
        Some(p) => run_file(&cli, &p),
        None => run_repl(&cli),
    };
}

/// Executes the provided source string
fn run(cli: &Cli, source: String) {
    let mut display_debug_info = false;

    if let Some(Commands::Debug(args)) = &cli.command {
        display_debug_info = args.debug_info;
    }

    // Lexer: Convert source string to tokens
    let (tokens, lexer_errs) = lexer().parse(&source).into_output_errors();
    let tokens = tokens.unwrap();

    if display_debug_info {
        println!(
            "=====TOKENS=====\n{:?}\n=====ERRORS=====\n{:?}\n",
            tokens, lexer_errs
        );
    }

    // Parser: Convert tokens to AST
    let (program, parse_errs) = parser()
        .map_with(|prog, e| (prog, e.span()))
        .parse(
            tokens
                .as_slice()
                .map((source.len()..source.len()).into(), |(t, s)| (t, s)),
        )
        .into_output_errors();
    let program = program.unwrap();

    if display_debug_info {
        println!(
            "=====AST TREE=====\n{:?}\n=====ERRORS=====\n{:?}\n",
            program, parse_errs
        );
    }

    // Typechecker: Checks if the type system is consistent in the AST
    let mut type_checker = TypeChecker::new();
    let type_check_result = type_checker.check_type(&program.0);

    if display_debug_info {
        match type_check_result {
            Ok(_) => println!("=====TYPE CHECK STATUS=====\nSUCCESS\n"),
            Err(e) => {
                println!("=====TYPE CHECK STATUS=====\nERROR:{:?}\n", e);
                return;
            }
        }
    }

    // Compiler: Translates AST to bytecode
    let mut compiler = Compiler::new();
    let compile_result = compiler.compile(&program.0);
    let program;

    match compile_result {
        Ok(prog) => {
            program = prog;

            if display_debug_info {
                println!(
                    "=====BYTECODE=====\n{:?}\n=====LABELS=====\n{:?}\n",
                    &program.instructions, &program.labels
                );
            }
        }
        Err(e) => {
            if display_debug_info {
                println!("=====COMPILATION ERROR=====\n{:?}\n", e);
            }
            return;
        }
    }

    // VM: Executes the generated bytecode
    let mut vm = VM::new();
    vm.run(&cli, program);
}

/// Run the REPL
fn run_repl(cli: &Cli) {
    println!("Running Exu REPL...");

    println!("Exu REPL Version 0.1.0");

    loop {
        let mut source: String = String::new();

        print!(">> ");
        io::stdout()
            .flush()
            .expect("An unexpected error occurred: Failed to flush stdout.");

        io::stdin()
            .read_line(&mut source)
            .expect("Unable to read from input.");

        run(&cli, source.trim().to_string());
    }
}

/// Run a source file given its path
fn run_file(cli: &Cli, path: &str) {
    let mut file: File = File::open(path).expect("Unable to open source file.");

    let mut source: String = String::new();
    file.read_to_string(&mut source)
        .expect("Unable to read source file.");

    run(&cli, source);
}
